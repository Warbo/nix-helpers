# Turns a list of Nix expressions into an attrset suitable for use in
# derivations, WITHOUT forcing anything to be built at eval time. Also provides
# a snippet of bash code to splice into scripts, which turns these env vars into
# a proper bash array.
#
# For example, if we did:
#
#   nixListToBashArray { name = "x"; args = [ "bar", "baz", <derivation..> ]; }
#
# We will get back an 'env' attrset like this:
#
#   { x1 = "bar"; x2 = "baz"; x3 = <derivation...>; }
#
# Note that the derivation hasn't been forced; if we append this set to a build
# environment, it will be treated like any other dependency. We also get a
# 'code' snippet, which will loop over these distinct variables to construct a
# single array (in this case, called "x")

# Take lib from nixpkgs1609, since other versions (e.g. 1603) mess up escaping
{ nixpkgs1609, nothing, runCmd }:

with builtins;
with nixpkgs1609.lib;
with rec {
  # This is the actual implementation
  go = { args, name }: rec {
    # Store each arg in a separate variable, named numerically
    env = with foldl' (result: arg: {
                        # Increment the count, for the next arg (if any)
                        count = result.count + 1;

                        # Append a variable to the environment for this arg
                        vars  = result.vars // {
                          "${name}${toString result.count}" = arg;
                        };
                      })
                      # Start with variable 1 in an empty environment
                      { count = 1; vars = {}; }
                      args;
          vars;

    code = ''
      ### Auto-generated by nixListToBashArray
      ${name}=()

      for N in $(seq 1 "${toString (length args)}")
      do
        # Use a "variable variable" to look up "$name$N" as a variable name
        NIXLISTTOBASHARRAYTEMP="${name}$N"
        ${name}=("''${${name}[@]}" "''${!NIXLISTTOBASHARRAYTEMP}")
        unset NIXLISTTOBASHARRAYTEMP
      done
      ### End of auto-generated code
    '';
  };

  ## Tests follow

  checkArgsAreNotForced =
    with go {
      name = "checkNotForced";
      args = [ (abort "NLTBA shouldn't have forced") ];
    };
    # Force the code to be generated, and hence the content of any splices
    (stringLength code > 0 || abort "No code generated") &&

    # Force the environment "spine"/structure to be generated
    (length (attrValues env) == 1 || abort "Wrong number of vars") &&

    # Force the variable names (but not values!) to be generated
    (attrNames env == [ "checkNotForced1" ] || abort "Wrong var name");

  checkWeGetTheRightValues =
    with { mixture = ''mixture "of 'special" $characters''; };
    with go {
           name = "foo";
           args = [ "simple" "single 'quoted'" ''double "quoted"''
                    mixture nothing ];
         };
    with rec {
      context = env;

      check = runCmd "check-NLTBA.nix" context ''
        function fail() {
          echo -e "$*" 1>&2
          exit 1
        }

        function match() {
          [[ "x$2" = "x$3" ]] || fail "Wrong $1 value '$2' (should be '$3')"
        }

        match foo1 "$foo1" "simple"
        match foo2 "$foo2" "single 'quoted'"
        match foo3 "$foo3" 'double "quoted"'
        match foo4 "$foo4" ${escapeShellArg mixture}

        [[ -d "$foo5" ]] || fail "foo5 should have been dir, got '$foo5'"

        ${code}

        [[ -n "$foo" ]] || fail "Didn't get foo: '$foo'"

        FOUND=0
        for VAL in "''${foo[@]}"
        do
          FOUND=$(( FOUND + 1 ))
        done
        [[ "$FOUND" -eq 5 ]] || fail "foo has '$FOUND' elements"

        match 'foo[0]' "''${foo[0]}" "simple"
        match 'foo[1]' "''${foo[1]}" "single 'quoted'"
        match 'foo[2]' "''${foo[2]}" 'double "quoted"'
        match 'foo[3]' "''${foo[3]}" ${escapeShellArg mixture}

        [[ -d "''${foo[4]}" ]] || fail "foo[4] should be dir, got: ''${foo[4]}"

        echo true > "$out"
      '';
    };
    import check;
};

assert checkArgsAreNotForced;
assert checkWeGetTheRightValues;
go
